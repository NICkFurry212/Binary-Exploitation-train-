So they provice us two things: binary file and a libc file.

Hint: PWNTools has a lot of useful features for getting offsets.

First thing first we gonna patch the libc file into binary file by using pwninit
![image](https://user-images.githubusercontent.com/114044703/218262859-f0c0d4b8-26bf-46f9-9a03-152b5aaef5a8.png)

Let's take a look at the binary:

```
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ file vuln_patched
vuln_patched: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-2.27.so, for GNU/Linux 3.2.0, BuildID[sha1]=e5dba3e6ed29e457cd104accb279e127285eecd0, not stripped
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ pwn checksec vuln_patched
/usr/lib/python3/dist-packages/pkg_resources/__init__.py:123: PkgResourcesDeprecationWarning: 2.3.0-nmu1-b1 is an invalid version and will not be supported in a future release
  warnings.warn(
[*] "/home/kali/Downloads/pico/Here's a LIBC/vuln_patched"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ ./vuln_patched
WeLcOmE To mY EcHo sErVeR!
asdf
AsDf
as
As
```

So we can see that it is `64` bit without RELRO, a NON-Excutable Stack and no PIE. We can see that when we run the binary. It allow us for input, and print out the text we have type in with the change of uppercase or lowercase.When we take a look at the main function in Ghidra we see this:

```
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v4; // al
  char *v5; // rdi
  const char **v6; // [rsp+0h] [rbp-80h] BYREF
  int v7; // [rsp+Ch] [rbp-74h]
  char v8[40]; // [rsp+10h] [rbp-70h] BYREF
  char *s; // [rsp+38h] [rbp-48h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  unsigned __int64 v11; // [rsp+48h] [rbp-38h]
  __gid_t rgid; // [rsp+54h] [rbp-2Ch]
  unsigned __int64 i; // [rsp+58h] [rbp-28h]

  v7 = argc;
  v6 = argv;
  setbuf(_bss_start, 0LL);
  rgid = getegid();
  setresgid(rgid, rgid, rgid);
  v11 = 27LL;
  strcpy(v8, "Welcome to my echo server!");
  v10 = 26LL;
  v3 = alloca(32LL);
  s = (char *)&v6;
  for ( i = 0LL; i < v11; ++i )
  {
    v4 = convert_case((unsigned int)v8[i], i);
    s[i] = v4;
  }
  v5 = s;
  puts(s);
  while ( 1 )
    do_stuff(v5);
}
```

At the start, the program do not much, It just printting out wellcome text with random character been uppercase. We gonna work with func `do_stuff`:

```
int do_stuff()
{
  char v0; // al
  char v2; // [rsp+Fh] [rbp-81h] BYREF
  char s[112]; // [rsp+10h] [rbp-80h] BYREF
  __int64 v4; // [rsp+80h] [rbp-10h]
  unsigned __int64 i; // [rsp+88h] [rbp-8h]

  v4 = 0LL;
  __isoc99_scanf("%[^\n]", input);
  __isoc99_scanf("%c", &v2);
  for ( i = 0LL; i <= 0x63; ++i )
  {
    v0 = convert_case((unsigned int)input[i], i);
    input[i] = v0;
  }
  return puts(input);
}
```

So the first `scanf` will take input from user until it see new line character or `\n`. The second scanf will take the new line character from above. So that we not gonna care about when to use sendline or send anymore.

When checking with ghidra we will see that `input` have buffer over flow vulnerable because it has the size of `112` but the first scanf has no limit the size from user.

**BrainStormming**

- We have known that program have buffer over flow vulnerable, have no win func and `NX` is turn on so we can do the ret2shellcode or ret2win.
- Chanlenge provide us a libc file so that we have known the libc version of sever we can do ret2libc or easier we can do ROP if program has enough gadget.











